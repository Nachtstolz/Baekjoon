# 10451 # BFS/DFS # 성공! # 파이썬의 재귀 제한 설정 함수 숙지
# 순열 사이클

# 1부터 N까지 정수 N개로 이루어진 순열을 나타내는 방법은 여러가지가 있다.
# 예를 들어, 8개의 수로 이루어진 순열 (3,2,7,8,1,4,5,6)을 배열을 이용해 표현하면
# ( 1 2 3 4 5 6 7 8 )
# ( 3 2 7 8 1 4 5 6 ) 와 같다.
# 순열을 배열을 이용해 이처럼 나타내고, 간선을 이어 그래프로 만들 수 있다.
# 이러한 사이클을 '순열 사이클'이라고 한다.
# N개의 정수로 이루어진 순열이 주어졌을 때, 순열 사이클의 개수를 구하는 프로그램을 작성하시오.

# 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 순열의 크기 N(2<=N<=1,000)이
# 주어진다. 둘째 줄에는 순열이 주어지며 각 정수는 공백으로 구분되어 있다.
# 각 테스트 케이스마다, 입력으로 주어진 순열에 존재하는 순열 사이클의 개수를 출력한다.

import sys

sys.setrecursionlimit(2000) # 파이썬의 기본 재귀 깊이 제한이 1000이므로
# 재귀 깊이 제한을 늘리기 위한 코드. 2000대신 10**6과 같은 큰 값을 사용해도 됨.
def dfs(li, visited, j) :
    if visited[j] == 1 :
        return
    visited[j] = 1
    dfs(li, visited, li[j]) # li[j]가 가리키는 값을 인덱스 삼아 이동

# 테스트 케이스의 개수 입력
t = int(input())
for i in range(t) :
    n = int(input()) # 순열 크기
    li = list(map(int, input().split())) # 순열
    li.insert(0, 0) # 0번 인덱스에 0을 삽입해 1번 인덱스부터 순열 값이 저장되게
    visited = [0] * (n+1) # 방문 여부를 체크하기 위한 배열 생성
    cycle = 0 # 사이클 개수 저장 변수
    for j in range(1, n+1) :
        # 0번 인덱스부터 돌면서 방문 여부 탐색하기
        if visited[j] == 1 : # 이미 방문한 곳은 넘어가기
            continue
        dfs(li, visited, j)
        cycle += 1 # 사이클이 생성되면 종료되기에 사이클 개수 증가
    print(cycle)
    