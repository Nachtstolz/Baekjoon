# 1149 # 성공! # 코드 참고해서 진행 완료
# 다이나믹 프로그래밍 좀 더 숙지하기
# 런타임 에러 발생 원인은 arr 범위 때문이었던...
# RGB 거리
# RGB 거리에는 집에 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
# 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는
# 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
 
# 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
# N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
# i(2<=i<=N-1)번 집의 색은 i-1번,i+1번 집의 색과 같지 않아야 한다.

# 다이나믹 프로그래밍 # 피보나치 수열 떠올리기 # 탑다운 / 바텀업
n = int(input())
#arr = list()
# 2차원 배열 초기화. 그냥 숫자 받을 배열로 만드는 법은 없나ㅠ
# arr = [[0]*3 for row in range(8)]

# for i in range(n) :
#     arr[i][0], arr[i][1], arr[i][2] = map(int, input().split(" "))
arr = []
for _ in range(n) :
    arr.append(list(map(int, input().split())))

# 제일 작은 값을 구하는 게 맞을까?.... 는 모르겠어
# 세 값의 차이를 구해서 그 중 가장 작은 것을 선택할 수 있으면 좋겠는데...

dp = [[0]*3 for i in range(n)]
dp[0] = arr[0]

# 해답 : 첫 번째 집을 R / G / B로 칠한 경우 세 가지를 나누어서 생각해 N번째까지 계산
for i in range(1, n) :
    dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + arr[i][0]
    dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + arr[i][1]
    dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + arr[i][2]

    # arr[i][0] += min(arr[i-1][1], arr[i-1][2])
    # arr[i][1] += min(arr[i-1][0], arr[i-1][2])
    # arr[i][2] += min(arr[i-1][0], arr[i-1][1])
    
print(min(dp[n-1]))
