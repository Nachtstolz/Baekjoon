# 2331 # BFS # 성공! 
# 반복수열

# 다음과 같이 정의된 수열이 있다.
# D[1] = A, D[n] = D[n-1]의 각 자리의 숫자를 P번 곱한 수들의 합.
# 예를 들어, A=57 P=2일 때, 수열 D는 [57, 74(=25+49), 65, 61, 37, 58, 89,
# 145, 42, 20, 4, 16, 37, ...] 이 된다.
# 그 뒤에는 앞서 나온 수들(57부터가 아니라 58부터)이 반복된다.
# 이와 같은 수열을 계속 구하다 보면 언젠가 이와 같은 반복수열이 된다. 이때, 반복되는 부분을
# 제외했을 때, 수열에 남게 되는 수들의 개수를 구하는 프로그램을 작성하시오.
# 위의 예에서는 [57, 74, 65, 61]의 네 개의 수가 남게 된다.

# 첫째 줄에 A(1<=A<=9999), P(1<=P<=5)가 주어진다.
# 첫째 줄에 반복되는 부분을 제외했을 때, 수열에 남게 되는 수들의 개수를 출력한다.

from collections import deque
# 이미 배열에 있는 수가 나오는 순간 정지 -> len 구하기
a, p = map(int, input().split())
visited = [0] * 1000001 # 방문 여부 체크할 배열

q = deque([a])
count = 1 # 몇 번째 방문 노드인지 기록
last = 0 # 겹치기 시작하는 노드가 몇 번째 노드인지 저장
while q :
    num = q.popleft()
    if visited[num] != 0 : # 방문 여부 체크
        last = visited[num] # 이미 방문했다면 방문했던 순서 저장.
        break
    visited[num] = count # 방문 순서 저장
    count+=1
    next = 0 # 다음으로 방문할 값 
    tmp = list(str(num))
    for i in tmp :
        i = int(i)
        next += i**p
    q.append(next)
print(last-1)